{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to App-Enhance's documentation!\n#\n\n\nApp-Enhance\n is a set of boilerplate/extensions libraries for any .Net application. All code is based on\n\n.Net Core\n and .NETStandard Library 1.5. It tries to cover and simplify many common use cases which you can encounter when you create\nreal applications. They are dependency injection, events, messaging, transactions and persistence.\n\n\nPlease follow navigation co read documentation.\n\n\nProject structure\n#\n\n\n\n\n\n\n\n\nArea\n\n\nRepository\n\n\nPackages\n\n\n\n\n\n\n\n\n\n\nDependency injection\n\n\nae-di\n\n\nAE.Extensions.DependencyInjection.Abstractions \n AE.Extensions.DependencyInjection\n\n\n\n\n\n\nEvents\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nTransactions\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nMessaging\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nPersistence\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nDomain Driven Design\n\n\nae-core\n\n\n?\n\n\n\n\n\n\n\n\nThe main rules which ennoble libraries created in this project are: \nsimplicity of code\n, \nextensibility\n, \nLess coupling\n, \nIoC based\n\nand \nvery lightweight", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-app-enhances-documentation", 
            "text": "App-Enhance  is a set of boilerplate/extensions libraries for any .Net application. All code is based on .Net Core  and .NETStandard Library 1.5. It tries to cover and simplify many common use cases which you can encounter when you create\nreal applications. They are dependency injection, events, messaging, transactions and persistence.  Please follow navigation co read documentation.", 
            "title": "Welcome to App-Enhance's documentation!"
        }, 
        {
            "location": "/#project-structure", 
            "text": "Area  Repository  Packages      Dependency injection  ae-di  AE.Extensions.DependencyInjection.Abstractions   AE.Extensions.DependencyInjection    Events  ae-core  ?    Transactions  ae-core  ?    Messaging  ae-core  ?    Persistence  ae-core  ?    Domain Driven Design  ae-core  ?     The main rules which ennoble libraries created in this project are:  simplicity of code ,  extensibility ,  Less coupling ,  IoC based \nand  very lightweight", 
            "title": "Project structure"
        }, 
        {
            "location": "/dependency-injection/", 
            "text": "AE.Extensions.DependencyInjection\n#\n\n\nThis is an extension library for \nMicrosoft.Extensions.DependencyInjection\n which provides you with a declarative way to pick out lifetime of services and register them in just a few lines.\n\n\nMotivation\n#\n\n\nWhen you want to register a service (create dependency) in \nIServiceCollection\n you have to describe at least 3 things.\n\n\n\n\nService interface\n\n\nService implementation\n\n\nLifetime scope\n\n\n\n\nUsusally it should look like this (see below)\n\n\n```c#\n// Method ex. in Startup.cs\n// doc: http://docs.asp.net/en/latest/fundamentals/dependency-injection.html\n\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    var serviceDescriptor = new ServiceDescriptor(typeof(IBankManager), typeof(BankManager), ServiceLifetime.Transient);\n    services.Add(serviceDescriptor);\n    // or \n    services.AddTransient\n();\n\n\n// Add MVC services to the services container.\nservices.AddMvc();\n\n\n\n\n\n}\n\n\n```c#\n/// And service definition somewhere, deeper in the code\npublic interface IBankManager\n{\n    int OpenAccount(string clientName);\n}\n\npublic class BankManager : IBankManager\n{\n    public int OpenAccount(string clientName)\n    {\n        // Account creating process...\n\n        return Random.Next(1000000, 9999999);\n    }\n}\n\n\n\n\n\nEvery service must be described in \nConfigureServices\n method manualy which means that something can be easily missed.\nMany people who create libraries like MVC they add static extension methods to simplify registration. \nIt means all descriptions of their services are hidden. \nThey make our life easier but what about our own custom services ? What if you have dozens of them ?\n\n\nI'm inspired by how Orchard team resolves that issue. \nThey created interfaces which correspond to lifetime scopes. So every service interface inherits appropriate \"scope interface\" and describes dependencies to register in global container.\nIn my case it looks like below - interfaces correspond exactly to \nServiceLifetime\n enum.\n\n\n```c#\n// You can use it to get all dependencies\npublic interface IDependency\n{\n}\n\n\npublic interface ISingletonDependency : IDependency\n{\n}\n\n\npublic interface IScopedDependency : IDependency\n{\n}\n\n\npublic interface ITransientDependency : IDependency\n{\n}\n\n\n// Omit registration for special cases\npublic interface INotRegisterDependency\n{\n}\n\n\n## Goals/Features\n\n- [x] [Declarative way of defining lifetime scope](https://github.com/app-enhance/ae-di#how-does-it-work)\n- [x] [Retrieval servies from assemblies](https://github.com/app-enhance/ae-di#how-does-it-work)\n- [ ] [Repleace dependencies (Decorate)](https://github.com/app-enhance/ae-di#repleace-dependency)\n  - [x] Repleace already registered services\n  - [x] Repleace dependencies from declarative way\n  - [ ] Add wrapper over IServiceCollection to lazy registration\n- [ ] [Proxing whole interfaces](https://github.com/app-enhance/ae-di#create-proxy-over-service)\n- [ ] [Integrations with popular containers](https://github.com/app-enhance/ae-di#integrations)\n  - [ ] [Autofac](https://github.com/app-enhance/ae-di#autofac)\n  - [ ] [Ninject](https://github.com/app-enhance/ae-di#ninject)\n\n## How does it work?\n\nIn order to use this approach you have to do two things:\n\n* Select dependency interface and inherit\n\n```c#\n// It will be registered as a \n// new ServiceDescriptor(typeof(IBankManager), typeof(BankManager), ServiceLifetime.Transient);\npublic interface IBankManager : ITransientDependency\n{\n    int OpenAccount(string clientName);\n}\n\npublic class BankManager : IBankManager\n{\n    public int OpenAccount(string clientName)\n    {\n        // Account creating process...\n\n        return Random.Next(1000000, 9999999);\n    }\n}\n\n\n\n\n\n\n\nUse extensions methods for \nIServiceCollection\n or \nServiceDescriptorsBuilder\n to retrieve all dependencies from assemblies (see below)\n\n\n\n\n```c#\npublic void ConfigureServices(IServiceCollection services)\n{\n    var assemblies = ... Get all assemblies ex. by ILibraryLoader or Assembly.GetExecutingAssembly(...) etc.\n    services.AddFromAssemblies(assemblies);\n\n\n// Add MVC services to the services container.\nservices.AddMvc();\n\n\n\n\n\n}\n\n\nThere are many custom ways to use service description builder. Most cases described [here](https://github.com/app-enhance/ae-di/wiki/Custom-usage-of-service-descriptions-builder)\n\n### Repleace service\nThere is possible to override implementaion of service (decorate) which was registered. You can do that by `RepleaceServiceAttribute` (see exapmle below)\n\n```c#\n[RepleaceService(typeof(BankManager))]\npublic class AuditBankManager : BankManager\n{\n    // Suppose that OpenAccount is virtual\n    public override int OpenAccount(string clientName)\n    {\n        // Do audit...\n\n        var accountNumber = base.OpenAccount(clientName);\n\n        // Do more audit...\n\n        return accountNumber;\n    }\n}\n\n\n\n\n\nRepleace dependency works also with services alredy added to \nIServiceCollection\n. TODO: possibility to repleace services added after using this extension.\n\n\nThere is another attibute \nDecorateServiceAttribute\n which works the same (inherit of \nRepleaceServiceAttribute\n). It is introduced due to semantics and in order to improve code cleanliness.\n\n\nCreate proxy over service\n#\n\n\n(todo)\n\n\nIntegrations\n#\n\n\nAutofac\n#\n\n\n(todo)\n\n\nNinject\n#\n\n\n(todo)\n\n\nContribute\n#\n\n\nBefore pushing new feature or improvement please read \nCONTRIBUTING.md", 
            "title": "Home"
        }, 
        {
            "location": "/dependency-injection/#aeextensionsdependencyinjection", 
            "text": "This is an extension library for  Microsoft.Extensions.DependencyInjection  which provides you with a declarative way to pick out lifetime of services and register them in just a few lines.", 
            "title": "AE.Extensions.DependencyInjection"
        }, 
        {
            "location": "/dependency-injection/#motivation", 
            "text": "When you want to register a service (create dependency) in  IServiceCollection  you have to describe at least 3 things.   Service interface  Service implementation  Lifetime scope   Ususally it should look like this (see below)  ```c#\n// Method ex. in Startup.cs\n// doc: http://docs.asp.net/en/latest/fundamentals/dependency-injection.html  public void ConfigureServices(IServiceCollection services)\n{\n    var serviceDescriptor = new ServiceDescriptor(typeof(IBankManager), typeof(BankManager), ServiceLifetime.Transient);\n    services.Add(serviceDescriptor);\n    // or \n    services.AddTransient ();  // Add MVC services to the services container.\nservices.AddMvc();  }  ```c#\n/// And service definition somewhere, deeper in the code\npublic interface IBankManager\n{\n    int OpenAccount(string clientName);\n}\n\npublic class BankManager : IBankManager\n{\n    public int OpenAccount(string clientName)\n    {\n        // Account creating process...\n\n        return Random.Next(1000000, 9999999);\n    }\n}  Every service must be described in  ConfigureServices  method manualy which means that something can be easily missed.\nMany people who create libraries like MVC they add static extension methods to simplify registration. \nIt means all descriptions of their services are hidden. \nThey make our life easier but what about our own custom services ? What if you have dozens of them ?  I'm inspired by how Orchard team resolves that issue. \nThey created interfaces which correspond to lifetime scopes. So every service interface inherits appropriate \"scope interface\" and describes dependencies to register in global container.\nIn my case it looks like below - interfaces correspond exactly to  ServiceLifetime  enum.  ```c#\n// You can use it to get all dependencies\npublic interface IDependency\n{\n}  public interface ISingletonDependency : IDependency\n{\n}  public interface IScopedDependency : IDependency\n{\n}  public interface ITransientDependency : IDependency\n{\n}  // Omit registration for special cases\npublic interface INotRegisterDependency\n{\n}  ## Goals/Features\n\n- [x] [Declarative way of defining lifetime scope](https://github.com/app-enhance/ae-di#how-does-it-work)\n- [x] [Retrieval servies from assemblies](https://github.com/app-enhance/ae-di#how-does-it-work)\n- [ ] [Repleace dependencies (Decorate)](https://github.com/app-enhance/ae-di#repleace-dependency)\n  - [x] Repleace already registered services\n  - [x] Repleace dependencies from declarative way\n  - [ ] Add wrapper over IServiceCollection to lazy registration\n- [ ] [Proxing whole interfaces](https://github.com/app-enhance/ae-di#create-proxy-over-service)\n- [ ] [Integrations with popular containers](https://github.com/app-enhance/ae-di#integrations)\n  - [ ] [Autofac](https://github.com/app-enhance/ae-di#autofac)\n  - [ ] [Ninject](https://github.com/app-enhance/ae-di#ninject)\n\n## How does it work?\n\nIn order to use this approach you have to do two things:\n\n* Select dependency interface and inherit\n\n```c#\n// It will be registered as a \n// new ServiceDescriptor(typeof(IBankManager), typeof(BankManager), ServiceLifetime.Transient);\npublic interface IBankManager : ITransientDependency\n{\n    int OpenAccount(string clientName);\n}\n\npublic class BankManager : IBankManager\n{\n    public int OpenAccount(string clientName)\n    {\n        // Account creating process...\n\n        return Random.Next(1000000, 9999999);\n    }\n}   Use extensions methods for  IServiceCollection  or  ServiceDescriptorsBuilder  to retrieve all dependencies from assemblies (see below)   ```c#\npublic void ConfigureServices(IServiceCollection services)\n{\n    var assemblies = ... Get all assemblies ex. by ILibraryLoader or Assembly.GetExecutingAssembly(...) etc.\n    services.AddFromAssemblies(assemblies);  // Add MVC services to the services container.\nservices.AddMvc();  }  There are many custom ways to use service description builder. Most cases described [here](https://github.com/app-enhance/ae-di/wiki/Custom-usage-of-service-descriptions-builder)\n\n### Repleace service\nThere is possible to override implementaion of service (decorate) which was registered. You can do that by `RepleaceServiceAttribute` (see exapmle below)\n\n```c#\n[RepleaceService(typeof(BankManager))]\npublic class AuditBankManager : BankManager\n{\n    // Suppose that OpenAccount is virtual\n    public override int OpenAccount(string clientName)\n    {\n        // Do audit...\n\n        var accountNumber = base.OpenAccount(clientName);\n\n        // Do more audit...\n\n        return accountNumber;\n    }\n}  Repleace dependency works also with services alredy added to  IServiceCollection . TODO: possibility to repleace services added after using this extension.  There is another attibute  DecorateServiceAttribute  which works the same (inherit of  RepleaceServiceAttribute ). It is introduced due to semantics and in order to improve code cleanliness.", 
            "title": "Motivation"
        }, 
        {
            "location": "/dependency-injection/#create-proxy-over-service", 
            "text": "(todo)", 
            "title": "Create proxy over service"
        }, 
        {
            "location": "/dependency-injection/#integrations", 
            "text": "", 
            "title": "Integrations"
        }, 
        {
            "location": "/dependency-injection/#autofac", 
            "text": "(todo)", 
            "title": "Autofac"
        }, 
        {
            "location": "/dependency-injection/#ninject", 
            "text": "(todo)", 
            "title": "Ninject"
        }, 
        {
            "location": "/dependency-injection/#contribute", 
            "text": "Before pushing new feature or improvement please read  CONTRIBUTING.md", 
            "title": "Contribute"
        }
    ]
}