{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to App-Enhance's documentation!\n#\n\n\nApp-Enhance\n is a set of boilerplate/extensions libraries for any .Net application. All code is based on\n\n.Net Core\n and .NETStandard Library 1.5. It tries to cover and simplify many common use cases which you can encounter when you create\nreal applications. They are dependency injection, events, messaging, transactions and persistence.\n\n\nPlease follow navigation co read documentation.\n\n\nProject structure\n#\n\n\n\n\n\n\n\n\nArea\n\n\nRepository\n\n\nPackages\n\n\n\n\n\n\n\n\n\n\nDependency injection\n\n\nae-di\n\n\nAE.Extensions.DependencyInjection.Abstractions \n AE.Extensions.DependencyInjection\n\n\n\n\n\n\nEvents\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nTransactions\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nMessaging\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nPersistence\n\n\nae-core\n\n\n?\n\n\n\n\n\n\nDomain Driven Design\n\n\nae-core\n\n\n?\n\n\n\n\n\n\n\n\nThe main rules which ennoble libraries created in this project are: \nsimplicity of code\n, \nextensibility\n, \nLess coupling\n, \nIoC based\n\nand \nvery lightweight\n\n\nGet involved\n#\n\n\nIf you have an interesting idea, any suggestions or bug report please add issue/PR to specific repository\nbut before pushing new feature or improvement please read \nContributing", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-app-enhances-documentation", 
            "text": "App-Enhance  is a set of boilerplate/extensions libraries for any .Net application. All code is based on .Net Core  and .NETStandard Library 1.5. It tries to cover and simplify many common use cases which you can encounter when you create\nreal applications. They are dependency injection, events, messaging, transactions and persistence.  Please follow navigation co read documentation.", 
            "title": "Welcome to App-Enhance's documentation!"
        }, 
        {
            "location": "/#project-structure", 
            "text": "Area  Repository  Packages      Dependency injection  ae-di  AE.Extensions.DependencyInjection.Abstractions   AE.Extensions.DependencyInjection    Events  ae-core  ?    Transactions  ae-core  ?    Messaging  ae-core  ?    Persistence  ae-core  ?    Domain Driven Design  ae-core  ?     The main rules which ennoble libraries created in this project are:  simplicity of code ,  extensibility ,  Less coupling ,  IoC based \nand  very lightweight", 
            "title": "Project structure"
        }, 
        {
            "location": "/#get-involved", 
            "text": "If you have an interesting idea, any suggestions or bug report please add issue/PR to specific repository\nbut before pushing new feature or improvement please read  Contributing", 
            "title": "Get involved"
        }, 
        {
            "location": "/dependency-injection/getting-started/", 
            "text": "Dependency injection\n#\n\n\nAE.Extensions.DependencyInjection\n packages are an extension library for \nMicrosoft.Extensions.DependencyInjection\n which provides you with a declarative way to pick out lifetime of services and register them in just a few lines.\n\n\nMotivation\n#\n\n\nWhen you want to register a service (create dependency) in \nIServiceCollection\n you have to describe at least 3 things:\n\n\n\n\nService interface\n\n\nService implementation\n\n\nLifetime scope\n\n\n\n\nUsually it should look like this (see below)\n\n\n// Method ex. in Startup.cs\n\n\n// doc: http://docs.asp.net/en/latest/fundamentals/dependency-injection.html\n\n\n\npublic\n \nvoid\n \nConfigureServices\n(\nIServiceCollection\n \nservices\n)\n\n\n{\n\n    \nvar\n \nserviceDescriptor\n \n=\n \nnew\n \nServiceDescriptor\n(\ntypeof\n(\nIBankManager\n),\n \ntypeof\n(\nBankManager\n),\n \nServiceLifetime\n.\nTransient\n);\n\n    \nservices\n.\nAdd\n(\nserviceDescriptor\n);\n\n    \n// or\n\n    \nservices\n.\nAddTransient\nIBankManager\n,\n \nBankManager\n();\n\n\n    \n// Add MVC services to the services container.\n\n    \nservices\n.\nAddMvc\n();\n\n\n}\n\n\n\n\n\n\n/// And service definition somewhere, deeper in the code\n\n\npublic\n \ninterface\n \nIBankManager\n\n\n{\n\n    \nint\n \nOpenAccount\n(\nstring\n \nclientName\n);\n\n\n}\n\n\n\npublic\n \nclass\n \nBankManager\n \n:\n \nIBankManager\n\n\n{\n\n    \npublic\n \nint\n \nOpenAccount\n(\nstring\n \nclientName\n)\n\n    \n{\n\n        \n// Account creating process...\n\n\n        \nreturn\n \nRandom\n.\nNext\n(\n1000000\n,\n \n9999999\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nEvery service must be described in \nConfigureServices\n method manualy which means that something can be easily missed.\nMany people who create libraries like MVC they add static extension methods to simplify registration.\nIt means all descriptions of their services are hidden.\nThey make our life easier but what about our own custom services ? What if you have dozens of them ?\n\n\nOverview\n#\n\n\nI'm inspired by how Orchard team resolves that issue.\nThey created interfaces which correspond to lifetime scopes. So every service interface inherits appropriate \"scope interface\" and describes dependencies to register in global container.\nIn my case it looks like below - interfaces correspond exactly to \nServiceLifetime\n enum.\n\n\n// You can use it to get all dependencies\n\n\npublic\n \ninterface\n \nIDependency\n\n\n{\n\n\n}\n\n\n\npublic\n \ninterface\n \nISingletonDependency\n \n:\n \nIDependency\n\n\n{\n\n\n}\n\n\n\npublic\n \ninterface\n \nIScopedDependency\n \n:\n \nIDependency\n\n\n{\n\n\n}\n\n\n\npublic\n \ninterface\n \nITransientDependency\n \n:\n \nIDependency\n\n\n{\n\n\n}\n\n\n\n// Omit registration for special cases\n\n\npublic\n \ninterface\n \nINotRegisterDependency\n\n\n{\n\n\n}\n\n\n\n\n\n\nHow does it work?\n#\n\n\nIn order to use this approach you have to do two things:\n\n\n\n\nSelect dependency interface and inherit\n\n\n\n\n// It will be registered as a\n\n\n// new ServiceDescriptor(typeof(IBankManager), typeof(BankManager), ServiceLifetime.Transient);\n\n\npublic\n \ninterface\n \nIBankManager\n \n:\n \nITransientDependency\n\n\n{\n\n    \nint\n \nOpenAccount\n(\nstring\n \nclientName\n);\n\n\n}\n\n\n\npublic\n \nclass\n \nBankManager\n \n:\n \nIBankManager\n\n\n{\n\n    \npublic\n \nint\n \nOpenAccount\n(\nstring\n \nclientName\n)\n\n    \n{\n\n        \n// Account creating process...\n\n\n        \nreturn\n \nRandom\n.\nNext\n(\n1000000\n,\n \n9999999\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nUse extensions methods for \nIServiceCollection\n or \nServiceDescriptorsBuilder\n to retrieve all dependencies from assemblies (see below)\n\n\n\n\npublic\n \nvoid\n \nConfigureServices\n(\nIServiceCollection\n \nservices\n)\n\n\n{\n\n    \nvar\n \nassemblies\n \n=\n \n...\n \nGet\n \nall\n \nassemblies\n \nex\n.\n \nby\n \nILibraryLoader\n \nor\n \nAssembly\n.\nGetExecutingAssembly\n(...)\n \netc\n.\n\n    \nservices\n.\nAddFromAssemblies\n(\nassemblies\n);\n\n\n    \n// Add MVC services to the services container.\n\n    \nservices\n.\nAddMvc\n();\n\n\n}\n\n\n\n\n\n\nThere are many custom ways to use service description builder. Most cases described in \ncustomizations\n section.\nAlso you can find list of additional features \nhere", 
            "title": "Getting started"
        }, 
        {
            "location": "/dependency-injection/getting-started/#dependency-injection", 
            "text": "AE.Extensions.DependencyInjection  packages are an extension library for  Microsoft.Extensions.DependencyInjection  which provides you with a declarative way to pick out lifetime of services and register them in just a few lines.", 
            "title": "Dependency injection"
        }, 
        {
            "location": "/dependency-injection/getting-started/#motivation", 
            "text": "When you want to register a service (create dependency) in  IServiceCollection  you have to describe at least 3 things:   Service interface  Service implementation  Lifetime scope   Usually it should look like this (see below)  // Method ex. in Startup.cs  // doc: http://docs.asp.net/en/latest/fundamentals/dependency-injection.html  public   void   ConfigureServices ( IServiceCollection   services )  { \n     var   serviceDescriptor   =   new   ServiceDescriptor ( typeof ( IBankManager ),   typeof ( BankManager ),   ServiceLifetime . Transient ); \n     services . Add ( serviceDescriptor ); \n     // or \n     services . AddTransient IBankManager ,   BankManager (); \n\n     // Add MVC services to the services container. \n     services . AddMvc ();  }   /// And service definition somewhere, deeper in the code  public   interface   IBankManager  { \n     int   OpenAccount ( string   clientName );  }  public   class   BankManager   :   IBankManager  { \n     public   int   OpenAccount ( string   clientName ) \n     { \n         // Account creating process... \n\n         return   Random . Next ( 1000000 ,   9999999 ); \n     }  }   Every service must be described in  ConfigureServices  method manualy which means that something can be easily missed.\nMany people who create libraries like MVC they add static extension methods to simplify registration.\nIt means all descriptions of their services are hidden.\nThey make our life easier but what about our own custom services ? What if you have dozens of them ?", 
            "title": "Motivation"
        }, 
        {
            "location": "/dependency-injection/getting-started/#overview", 
            "text": "I'm inspired by how Orchard team resolves that issue.\nThey created interfaces which correspond to lifetime scopes. So every service interface inherits appropriate \"scope interface\" and describes dependencies to register in global container.\nIn my case it looks like below - interfaces correspond exactly to  ServiceLifetime  enum.  // You can use it to get all dependencies  public   interface   IDependency  {  }  public   interface   ISingletonDependency   :   IDependency  {  }  public   interface   IScopedDependency   :   IDependency  {  }  public   interface   ITransientDependency   :   IDependency  {  }  // Omit registration for special cases  public   interface   INotRegisterDependency  {  }", 
            "title": "Overview"
        }, 
        {
            "location": "/dependency-injection/getting-started/#how-does-it-work", 
            "text": "In order to use this approach you have to do two things:   Select dependency interface and inherit   // It will be registered as a  // new ServiceDescriptor(typeof(IBankManager), typeof(BankManager), ServiceLifetime.Transient);  public   interface   IBankManager   :   ITransientDependency  { \n     int   OpenAccount ( string   clientName );  }  public   class   BankManager   :   IBankManager  { \n     public   int   OpenAccount ( string   clientName ) \n     { \n         // Account creating process... \n\n         return   Random . Next ( 1000000 ,   9999999 ); \n     }  }    Use extensions methods for  IServiceCollection  or  ServiceDescriptorsBuilder  to retrieve all dependencies from assemblies (see below)   public   void   ConfigureServices ( IServiceCollection   services )  { \n     var   assemblies   =   ...   Get   all   assemblies   ex .   by   ILibraryLoader   or   Assembly . GetExecutingAssembly (...)   etc . \n     services . AddFromAssemblies ( assemblies ); \n\n     // Add MVC services to the services container. \n     services . AddMvc ();  }   There are many custom ways to use service description builder. Most cases described in  customizations  section.\nAlso you can find list of additional features  here", 
            "title": "How does it work?"
        }, 
        {
            "location": "/dependency-injection/features/", 
            "text": "Below are described common features which provide abstractions part of this library.\n\n\nRepleace service\n#\n\n\nThere is possible to override implementaion of service (decorate) which was registered. You can do that by \nRepleaceServiceAttribute\n (see exapmle below)\n\n\n[RepleaceService(typeof(BankManager))]\n\n\npublic\n \nclass\n \nAuditBankManager\n \n:\n \nBankManager\n\n\n{\n\n    \n// Suppose that OpenAccount is virtual\n\n    \npublic\n \noverride\n \nint\n \nOpenAccount\n(\nstring\n \nclientName\n)\n\n    \n{\n\n        \n// Do audit...\n\n\n        \nvar\n \naccountNumber\n \n=\n \nbase\n.\nOpenAccount\n(\nclientName\n);\n\n\n        \n// Do more audit...\n\n\n        \nreturn\n \naccountNumber\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRepleace dependency works also with services alredy added to \nIServiceCollection\n. TODO: possibility to repleace services added after using this extension.\n\n\nThere is another attibute \nDecorateServiceAttribute\n which works the same (inherit of \nRepleaceServiceAttribute\n). It is introduced due to semantics and in order to improve code cleanliness.\n\n\nCreate proxy over service\n#\n\n\n(todo)", 
            "title": "Features"
        }, 
        {
            "location": "/dependency-injection/features/#repleace-service", 
            "text": "There is possible to override implementaion of service (decorate) which was registered. You can do that by  RepleaceServiceAttribute  (see exapmle below)  [RepleaceService(typeof(BankManager))]  public   class   AuditBankManager   :   BankManager  { \n     // Suppose that OpenAccount is virtual \n     public   override   int   OpenAccount ( string   clientName ) \n     { \n         // Do audit... \n\n         var   accountNumber   =   base . OpenAccount ( clientName ); \n\n         // Do more audit... \n\n         return   accountNumber ; \n     }  }   Repleace dependency works also with services alredy added to  IServiceCollection . TODO: possibility to repleace services added after using this extension.  There is another attibute  DecorateServiceAttribute  which works the same (inherit of  RepleaceServiceAttribute ). It is introduced due to semantics and in order to improve code cleanliness.", 
            "title": "Repleace service"
        }, 
        {
            "location": "/dependency-injection/features/#create-proxy-over-service", 
            "text": "(todo)", 
            "title": "Create proxy over service"
        }, 
        {
            "location": "/dependency-injection/customizations/", 
            "text": "Todo\n#\n\n\nDescribe all customizations and possible ways to extend library.", 
            "title": "Customizations"
        }, 
        {
            "location": "/dependency-injection/customizations/#todo", 
            "text": "Describe all customizations and possible ways to extend library.", 
            "title": "Todo"
        }, 
        {
            "location": "/dependency-injection/integrations/", 
            "text": "Integrations\n#\n\n\nAutofac\n#\n\n\n(todo)\n\n\nNinject\n#\n\n\n(todo)", 
            "title": "Integrations"
        }, 
        {
            "location": "/dependency-injection/integrations/#integrations", 
            "text": "", 
            "title": "Integrations"
        }, 
        {
            "location": "/dependency-injection/integrations/#autofac", 
            "text": "(todo)", 
            "title": "Autofac"
        }, 
        {
            "location": "/dependency-injection/integrations/#ninject", 
            "text": "(todo)", 
            "title": "Ninject"
        }, 
        {
            "location": "/dependency-injection/roadmap/", 
            "text": "Roadmap\n#\n\n\nBelow is list of features which are planed to implemented in version 1.0\n\n\nGoals/Features\n#\n\n\n\n\n \nDeclarative way of defining lifetime scope\n\n\n \nRetrieval servies from assemblies\n\n\n \nRepleace dependencies (Decorate)\n\n\n Repleace already registered services\n\n\n Repleace dependencies from declarative way\n\n\n Add wrapper over IServiceCollection to lazy registration\n\n\n \nProxing whole interfaces\n\n\n \nIntegrations with popular containers\n\n\n \nAutofac\n\n\n \nNinject", 
            "title": "Roadmap"
        }, 
        {
            "location": "/dependency-injection/roadmap/#roadmap", 
            "text": "Below is list of features which are planed to implemented in version 1.0", 
            "title": "Roadmap"
        }, 
        {
            "location": "/dependency-injection/roadmap/#goalsfeatures", 
            "text": "Declarative way of defining lifetime scope    Retrieval servies from assemblies    Repleace dependencies (Decorate)   Repleace already registered services   Repleace dependencies from declarative way   Add wrapper over IServiceCollection to lazy registration    Proxing whole interfaces    Integrations with popular containers    Autofac    Ninject", 
            "title": "Goals/Features"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n#\n\n\nBuild system\n#\n\n\nUse a new system called \nKoreBuild\n, which is built using the sake build tools.\n\nThe sake project is available here: \nhttps://github.com/sakeproject/sake\n\n\nCoding style guidelines\n#\n\n\n\n\nUse \nAllman style\n braces, where each brace begins on a new line.\n   A single line statement block cannot go without braces because of nesting and readability.\n\n\nUse four spaces of indentation (no tabs).\n\n\nUse \n_camelCase\n for private fields and use \nreadonly\n where possible.\n\n\nAvoid \nthis.\n unless absolutely necessary\n\n\nAlways specify member visibility, even if it's the default (i.e. \nprivate string _foo;\n not \nstring _foo;\n)\n\n\nNamespace imports should be specified at the top of the file, \ninside\n of \nnamespace\n declarations and should be sorted\n   alphabetically, with \nSystem.\n namespaces at the top and blank lines between different top level groups.\n\n\nAvoid more than one empty line at any time. For example, do not have two blank lines between members of a type.\n\n\nAvoid spurious free spaces. For example avoid \nif (someVar == 0)...\n, where the dots mark the spurious free spaces.\n   Consider enabling \"View White Space (Ctrl+E, S)\" if using Visual Studio, to aid detection.\n\n\nUse PascalCasing to name all our constant local variables and fields.\n\n\n\n\nUsage of the var keyword\n#\n\n\nThe \nvar\n keyword is to be used as much as the compiler will allow.\n\n\n\n\nThey are correct:\n\n\n\n\nvar\n \nfruit\n \n=\n \nLychee\n;\n\n\nvar\n \nfruits\n \n=\n \nnew\n \nList\nFruit\n();\n\n\nvar\n \nflavor\n \n=\n \nfruit\n.\nGetFlavor\n();\n\n\nstring\n \nfruit\n \n=\n \nnull\n;\n \n// can\nt use \nvar\n because the type isn\nt known (though you could do (string)null, don\nt!)\n\n\nconst\n \nstring\n \nexpectedName\n \n=\n \nname\n;\n \n// can\nt use \nvar\n with const\n\n\n\n\n\n\n\n\nThe following are incorrect:\n\n\n\n\nstring\n \nfruit\n \n=\n \nLychee\n;\n\n\nList\nFruit\n \nfruits\n \n=\n \nnew\n \nList\nFruit\n();\n\n\nFruitFlavor\n \nflavor\n \n=\n \nfruit\n.\nGetFlavor\n();\n\n\n\n\n\n\nUse csharp type keywords in favor of .NET type names\n#\n\n\nWhen using a type that has a csharp keyword the keyword is used in favor of the .NET type name.\n\n\n\n\nThey are correct:\n\n\n\n\npublic\n \nstring\n \nTrimString\n(\nstring\n \ns\n)\n\n\n{\n\n    \nreturn\n \nstring\n.\nIsNullOrEmpty\n(\ns\n)\n\n        \n?\n \nnull\n\n        \n:\n \ns\n.\nTrim\n();\n\n\n}\n\n\n\nvar\n \nintTypeName\n \n=\n \nnameof\n(\nInt32\n);\n \n// can\nt use csharp type keywords with nameof\n\n\n\n\n\n\n\n\nThe following are incorrect:\n\n\n\n\npublic\n \nString\n \nTrimString\n(\nString\n \ns\n)\n\n\n{\n\n    \nreturn\n \nString\n.\nIsNullOrEmpty\n(\ns\n)\n\n        \n?\n \nnull\n\n        \n:\n \ns\n.\nTrim\n();\n\n\n}\n\n\n\n\n\n\nUse only complete words or common/standard abbreviations in public APIs\n#\n\n\nPublic namespaces, type names, member names, and parameter names must use complete words or common/standard abbreviations.\n\n\n\n\nThey are correct:\n\n\n\n\npublic\n \nvoid\n \nAddReference\n(\nAssemblyReference\n \nreference\n);\n\n\npublic\n \nEcmaScriptObject\n \nSomeObject\n \n{\n \nget\n;\n \n}\n\n\n\n\n\n\n\n\nThe following are incorrect:\n\n\n\n\npublic\n \nvoid\n \nAddRef\n(\nAssemblyReference\n \nref\n);\n\n\npublic\n \nEcmaScriptObject\n \nSomeObj\n \n{\n \nget\n;\n \n}\n\n\n\n\n\n\nCross-platform coding\n#\n\n\nFrameworks should work on CoreCLR, which supports multiple operating systems. Don't assume it only run (and develop) on Windows. Code should be sensitive to the differences between OS's. Here are some specifics to consider.\n\n\nLine breaks\n#\n\n\nWindows uses \n\\r\\n\n, OS X and Linux uses \n\\n\n. When it is important, use \nEnvironment.NewLine\n instead of hard-coding the line break.\n\n\nNote: this may not always be possible or necessary.\n\n\nBe aware that these line-endings may cause problems in code when using \n@\"\"\n text blocks with line breaks.\n\n\nEnvironment Variables\n#\n\n\nOS's use different variable names to represent similar settings. Code should consider these differences.\n\n\nFor example, when looking for the user's home directory, on Windows the variable is \nUSERPROFILE\n but on most Linux systems it is \nHOME\n.\n\n\nvar\n \nhomeDir\n \n=\n \nEnvironment\n.\nGetEnvironmentVariable\n(\nUSERPROFILE\n)\n\n                  \n??\n \nEnvironment\n.\nGetEnvironmentVariable\n(\nHOME\n);\n\n\n\n\n\n\nFile path separators\n#\n\n\nWindows uses \n\\\n and OS X and Linux use \n/\n to separate directories. Instead of hard-coding either type of slash, use \nPath.Combine()\n or \nPath.DirectorySeparatorChar\n.\n\n\nIf this is not possible (such as in scripting), use a forward slash. Windows is more forgiving than Linux in this regard.\n\n\nConditional compilation for Desktop/CoreCLR\n#\n\n\nAlmost all development is done for both CoreCLR and Desktop .NET. Some code will be CoreCLR-specific or Desktop-specific because of API changes or behavior differences. The build system has two conditional compilation statements to assist with this:\n\n\nDesktop:\n\n\n#\nifdef\n \nDNX451\n\n\n\n\n\n\nCoreCLR:\n\n\n#\nifdef\n \nDNXCORE50\n\n\n\n\n\n\nWhen to use internals vs. public and when to use InternalsVisibleTo\n#\n\n\nAs a modern set of frameworks, usage of internal types and members is allowed, but discouraged.\n\n\nInternalsVisibleTo\n is used only to allow a unit test to test internal types and members of its runtime assembly. Do not use \nInternalsVisibleTo\n between two runtime assemblies.\n\n\nIf two runtime assemblies need to share common helpers then use a \"shared source\" solution with build-time only packages. Check out the \nhttps://github.com/aspnet/Mvc/tree/dev/src/Microsoft.AspNet.Mvc.Common\n project and how it is referenced from the \nproject.json\n files of sibling projects.\n\n\nIf two runtime assemblies need to call each other's APIs, the APIs must be public. If it is need it, it is likely that other customers need it.\n\n\nExtension method patterns\n#\n\n\nThe general rule is: if a regular static method would suffice, avoid extension methods.\n\n\nExtension methods are often useful to create chainable method calls, for example, when constructing complex objects, or creating queries.\n\n\nInternal extension methods are allowed, but bear in mind the previous guideline: ask yourself if an extension method is truly the most appropriate pattern.\n\n\nThe namespace of the extension method class should generally be the namespace that represents the functionality of the extension method, as opposed to the namespace of the target type. One common exception to this is that the namespace for middleware extension methods is normally always the same is the namespace of \nIAppBuilder\n.\n\n\nThe class name of an extension method container (also known as a \"sponsor type\") should generally follow the pattern of \nFeature\nExtensions\n, \nTarget\nFeature\nExtensions\n, or \nFeature\nTarget\nExtensions\n. For example:\n\n\nnamespace\n \nFood\n\n\n{\n\n    \nclass\n \nFruit\n \n{\n \n...\n \n}\n\n\n}\n\n\n\nnamespace\n \nFruit.Eating\n\n\n{\n\n    \nclass\n \nFruitExtensions\n \n{\n \npublic\n \nstatic\n \nvoid\n \nEat\n(\nthis\n \nFruit\n \nfruit\n);\n \n}\n\n  \nOR\n\n    \nclass\n \nFruitEatingExtensions\n \n{\n \npublic\n \nstatic\n \nvoid\n \nEat\n(\nthis\n \nFruit\n \nfruit\n);\n \n}\n\n  \nOR\n\n    \nclass\n \nEatingFruitExtensions\n \n{\n \npublic\n \nstatic\n \nvoid\n \nEat\n(\nthis\n \nFruit\n \nfruit\n);\n \n}\n\n\n}\n\n\n\n\n\n\nWhen writing extension methods for an interface the sponsor type name must not start with an \nI\n.\n\n\nAssertions\n#\n\n\nUse \nDebug.Assert()\n to assert a condition in the code. Do not use Code Contracts (e.g. \nContract.Assert\n).\n\n\nPlease note that assertions are only for our own internal debugging purposes. They do not end up in the released code, so to alert a developer of a condition use an exception.\n\n\nUnit tests and functional tests\n#\n\n\nUse \nxUnit.net\n for all unit testing.\n\n\nAssembly naming\n#\n\n\nThe unit tests for the \nMicrosoft.Fruit\n assembly live in the \nMicrosoft.Fruit.Tests\n assembly.\n\n\nThe functional tests for the \nMicrosoft.Fruit\n assembly live in the \nMicrosoft.Fruit.FunctionalTests\n assembly.\n\n\nIn general there should be exactly one unit test assembly for each product runtime assembly. In general there should be one functional test assembly per repo. Exceptions can be made for both.\n\n\nUnit test class naming\n#\n\n\nTest class names end with \nTest\n and live in the same namespace as the class being tested. For example, the unit tests for the \nMicrosoft.Fruit.Banana\n class would be in a \nMicrosoft.Fruit.BananaTest\n class in the test assembly.\n\n\nUnit test method naming\n#\n\n\nUnit test method names must be descriptive about \nwhat is being tested\n, \nunder what conditions\n, and \nwhat the expectations are\n. Pascal casing and underscores can be used to improve readability. The following test names are correct:\n\n\n\n\nThey are correct:\n\n\n\n\nPublicApiArgumentsShouldHaveNotNullAnnotation\nPublic_api_arguments_should_have_not_null_annotation\n\n\n\n\n\n\n\nThe following test names are incorrect:\n\n\n\n\nTest1\nConstructor\nFormatString\nGetData\n\n\n\n\n\nUnit test structure\n#\n\n\nThe contents of every unit test should be split into three distinct stages, optionally separated by these comments:\n\n\n// Arrange  \n\n\n// Act  \n\n\n// Assert\n\n\n\n\n\n\nThe crucial thing here is that the \nAct\n stage is exactly one statement. That one statement is nothing more than a call to the one method that you are trying to test. Keeping that one statement as simple as possible is also very important. For example, this is not ideal:\n\n\nint\n \nresult\n \n=\n \nmyObj\n.\nCallSomeMethod\n(\nGetComplexParam1\n(),\n \nGetComplexParam2\n(),\n \nGetComplexParam3\n());\n\n\n\n\n\n\nThis style is not recommended because way too many things can go wrong in this one statement. All the \nGetComplexParamN()\n calls can throw for a variety of reasons unrelated to the test itself. It is thus unclear to someone running into a problem why the failure occurred.\n\n\nThe ideal pattern is to move the complex parameter building into the \nArrange\n section:\n\n\n// Arrange\n\n\nP1\n \np1\n \n=\n \nGetComplexParam1\n();\n\n\nP2\n \np2\n \n=\n \nGetComplexParam2\n();\n\n\nP3\n \np3\n \n=\n \nGetComplexParam3\n();\n\n\n\n// Act\n\n\nint\n \nresult\n \n=\n \nmyObj\n.\nCallSomeMethod\n(\np1\n,\n \np2\n,\n \np3\n);\n\n\n\n// Assert\n\n\nAssert\n.\nAreEqual\n(\n1234\n,\n \nresult\n);\n\n\n\n\n\n\nNow the only reason the line with \nCallSomeMethod()\n can fail is if the method itself blew up. This is especially important when you're using helpers such as \nExceptionHelper\n, where the delegate you pass into it must fail for exactly one reason.\n\n\nTesting exception messages\n#\n\n\nIn general testing the specific exception message in a unit test is important. This ensures that the exact desired exception is what is being tested rather than a different exception of the same type. In order to verify the exact exception it is important to verify the message.\n\n\nTo make writing unit tests easier it is recommended to compare the error message to the RESX resource. However, comparing against a string literal is also permitted.\n\n\nvar\n \nex\n \n=\n \nAssert\n.\nThrows\nInvalidOperationException\n(()\n \n=\n \nfruitBasket\n.\nGetBananaById\n(\n1234\n));\n\n\nAssert\n.\nEqual\n(\nStrings\n.\nFormatInvalidBananaID\n(\n1234\n),\n \nex\n.\nMessage\n);\n\n\n\n\n\n\nUse xUnit.net's plethora of built-in assertions\n#\n\n\nxUnit.net includes many kinds of assertions \u2013 please use the most appropriate one for your test. This will make the tests a lot more readable and also allow the test runner report the best possible errors (whether it's local or the CI machine). For example:\n\n\n\n\nThe following are incorrect:\n\n\n\n\nAssert\n.\nEqual\n(\ntrue\n,\n \nsomeBool\n);\n\n\nAssert\n.\nTrue\n(\nabc123\n \n==\n \nsomeString\n);\n\n\nAssert\n.\nTrue\n(\nlist1\n.\nLength\n \n==\n \nlist2\n.\nLength\n);\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nlist1\n.\nLength\n;\n \ni\n++)\n\n\n{\n\n    \nAssert\n.\nTrue\n(\nString\n.\nEquals\n,\n \nlist1\n[\ni\n],\n \nlist2\n[\ni\n],\n \nStringComparison\n.\nOrdinalIgnoreCase\n));\n\n\n}\n\n\n\n\n\n\n\n\nThey are good:\n\n\n\n\nAssert\n.\nTrue\n(\nsomeBool\n);\n\n\nAssert\n.\nEqual\n(\nabc123\n,\n \nsomeString\n);\n\n\n\n// built-in collection assertions!\n\n\nAssert\n.\nEqual\n(\nlist1\n,\n \nlist2\n,\n \nStringComparer\n.\nOrdinalIgnoreCase\n);\n\n\n\n\n\n\nParallel tests\n#\n\n\nBy default all unit test assemblies should run in parallel mode, which is the default. Unit tests shouldn't depend on any shared state, and so should generally be runnable in parallel. If the tests fail in parallel, the first thing to do is to figure out \nwhy\n; do not just disable parallel tests!\n\n\nFor functional tests it is reasonable to disable parallel tests.\n\n\nSolution and project folder structure and naming\n#\n\n\nSolution files go in the repo root.\n\n\nSolution names match repo names (e.g. Mvc.sln in the Mvc repo).\n\n\nEvery project also needs a \nproject.json\n and a matching \n.xproj\n file. This \nproject.json\n is the source of truth for a project's dependencies and configuration options.\n\n\nSolutions need to contain solution folders that match the physical folders (\nsrc\n, \ntest\n, etc.).\n\n\nFor example, in the \nFruit\n repo with the \nBanana\n and \nLychee\n projects you would have these files checked in:\n\n\n/Fruit.sln\n/src\n/src/Fruit.Banana\n/src/Fruit.Banana/project.json\n/src/Fruit.Banana/Banana.kproj\n/src/Fruit.Banana/Banana.cs\n/src/Fruit.Banana/Util/BananaUtil.cs\n/src/Fruit.Lychee\n/src/Fruit.Lychee/project.json\n/src/Fruit.Lychee/Lychee.kproj\n/src/Fruit.Lychee/Lychee.cs\n/src/Fruit.Lychee/Util/LycheeUtil.cs\n/test\n/test/Fruit.Banana.Tests\n/test/Fruit.Banana.Tests/project.json\n/test/Fruit.Banana.Tests/BananaTest.kproj\n/test/Fruit.Banana.Tests/BananaTest.cs\n/test/Fruit.Banana.Tests/Util/BananaUtilTest.cs\n\n\n\n\n\nNote that after running the \nbuild\n command the system will generate the following files:\n\n\n/build/*.shade\n\n\n\n\n\nAll these files are set to be ignored in the \n.gitignore\n file.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#build-system", 
            "text": "Use a new system called  KoreBuild , which is built using the sake build tools. \nThe sake project is available here:  https://github.com/sakeproject/sake", 
            "title": "Build system"
        }, 
        {
            "location": "/contributing/#coding-style-guidelines", 
            "text": "Use  Allman style  braces, where each brace begins on a new line.\n   A single line statement block cannot go without braces because of nesting and readability.  Use four spaces of indentation (no tabs).  Use  _camelCase  for private fields and use  readonly  where possible.  Avoid  this.  unless absolutely necessary  Always specify member visibility, even if it's the default (i.e.  private string _foo;  not  string _foo; )  Namespace imports should be specified at the top of the file,  inside  of  namespace  declarations and should be sorted\n   alphabetically, with  System.  namespaces at the top and blank lines between different top level groups.  Avoid more than one empty line at any time. For example, do not have two blank lines between members of a type.  Avoid spurious free spaces. For example avoid  if (someVar == 0)... , where the dots mark the spurious free spaces.\n   Consider enabling \"View White Space (Ctrl+E, S)\" if using Visual Studio, to aid detection.  Use PascalCasing to name all our constant local variables and fields.", 
            "title": "Coding style guidelines"
        }, 
        {
            "location": "/contributing/#usage-of-the-var-keyword", 
            "text": "The  var  keyword is to be used as much as the compiler will allow.   They are correct:   var   fruit   =   Lychee ;  var   fruits   =   new   List Fruit ();  var   flavor   =   fruit . GetFlavor ();  string   fruit   =   null ;   // can t use  var  because the type isn t known (though you could do (string)null, don t!)  const   string   expectedName   =   name ;   // can t use  var  with const    The following are incorrect:   string   fruit   =   Lychee ;  List Fruit   fruits   =   new   List Fruit ();  FruitFlavor   flavor   =   fruit . GetFlavor ();", 
            "title": "Usage of the var keyword"
        }, 
        {
            "location": "/contributing/#use-csharp-type-keywords-in-favor-of-net-type-names", 
            "text": "When using a type that has a csharp keyword the keyword is used in favor of the .NET type name.   They are correct:   public   string   TrimString ( string   s )  { \n     return   string . IsNullOrEmpty ( s ) \n         ?   null \n         :   s . Trim ();  }  var   intTypeName   =   nameof ( Int32 );   // can t use csharp type keywords with nameof    The following are incorrect:   public   String   TrimString ( String   s )  { \n     return   String . IsNullOrEmpty ( s ) \n         ?   null \n         :   s . Trim ();  }", 
            "title": "Use csharp type keywords in favor of .NET type names"
        }, 
        {
            "location": "/contributing/#use-only-complete-words-or-commonstandard-abbreviations-in-public-apis", 
            "text": "Public namespaces, type names, member names, and parameter names must use complete words or common/standard abbreviations.   They are correct:   public   void   AddReference ( AssemblyReference   reference );  public   EcmaScriptObject   SomeObject   {   get ;   }    The following are incorrect:   public   void   AddRef ( AssemblyReference   ref );  public   EcmaScriptObject   SomeObj   {   get ;   }", 
            "title": "Use only complete words or common/standard abbreviations in public APIs"
        }, 
        {
            "location": "/contributing/#cross-platform-coding", 
            "text": "Frameworks should work on CoreCLR, which supports multiple operating systems. Don't assume it only run (and develop) on Windows. Code should be sensitive to the differences between OS's. Here are some specifics to consider.", 
            "title": "Cross-platform coding"
        }, 
        {
            "location": "/contributing/#line-breaks", 
            "text": "Windows uses  \\r\\n , OS X and Linux uses  \\n . When it is important, use  Environment.NewLine  instead of hard-coding the line break.  Note: this may not always be possible or necessary.  Be aware that these line-endings may cause problems in code when using  @\"\"  text blocks with line breaks.", 
            "title": "Line breaks"
        }, 
        {
            "location": "/contributing/#environment-variables", 
            "text": "OS's use different variable names to represent similar settings. Code should consider these differences.  For example, when looking for the user's home directory, on Windows the variable is  USERPROFILE  but on most Linux systems it is  HOME .  var   homeDir   =   Environment . GetEnvironmentVariable ( USERPROFILE ) \n                   ??   Environment . GetEnvironmentVariable ( HOME );", 
            "title": "Environment Variables"
        }, 
        {
            "location": "/contributing/#file-path-separators", 
            "text": "Windows uses  \\  and OS X and Linux use  /  to separate directories. Instead of hard-coding either type of slash, use  Path.Combine()  or  Path.DirectorySeparatorChar .  If this is not possible (such as in scripting), use a forward slash. Windows is more forgiving than Linux in this regard.", 
            "title": "File path separators"
        }, 
        {
            "location": "/contributing/#conditional-compilation-for-desktopcoreclr", 
            "text": "Almost all development is done for both CoreCLR and Desktop .NET. Some code will be CoreCLR-specific or Desktop-specific because of API changes or behavior differences. The build system has two conditional compilation statements to assist with this:  Desktop:  # ifdef   DNX451   CoreCLR:  # ifdef   DNXCORE50", 
            "title": "Conditional compilation for Desktop/CoreCLR"
        }, 
        {
            "location": "/contributing/#when-to-use-internals-vs-public-and-when-to-use-internalsvisibleto", 
            "text": "As a modern set of frameworks, usage of internal types and members is allowed, but discouraged.  InternalsVisibleTo  is used only to allow a unit test to test internal types and members of its runtime assembly. Do not use  InternalsVisibleTo  between two runtime assemblies.  If two runtime assemblies need to share common helpers then use a \"shared source\" solution with build-time only packages. Check out the  https://github.com/aspnet/Mvc/tree/dev/src/Microsoft.AspNet.Mvc.Common  project and how it is referenced from the  project.json  files of sibling projects.  If two runtime assemblies need to call each other's APIs, the APIs must be public. If it is need it, it is likely that other customers need it.", 
            "title": "When to use internals vs. public and when to use InternalsVisibleTo"
        }, 
        {
            "location": "/contributing/#extension-method-patterns", 
            "text": "The general rule is: if a regular static method would suffice, avoid extension methods.  Extension methods are often useful to create chainable method calls, for example, when constructing complex objects, or creating queries.  Internal extension methods are allowed, but bear in mind the previous guideline: ask yourself if an extension method is truly the most appropriate pattern.  The namespace of the extension method class should generally be the namespace that represents the functionality of the extension method, as opposed to the namespace of the target type. One common exception to this is that the namespace for middleware extension methods is normally always the same is the namespace of  IAppBuilder .  The class name of an extension method container (also known as a \"sponsor type\") should generally follow the pattern of  Feature Extensions ,  Target Feature Extensions , or  Feature Target Extensions . For example:  namespace   Food  { \n     class   Fruit   {   ...   }  }  namespace   Fruit.Eating  { \n     class   FruitExtensions   {   public   static   void   Eat ( this   Fruit   fruit );   } \n   OR \n     class   FruitEatingExtensions   {   public   static   void   Eat ( this   Fruit   fruit );   } \n   OR \n     class   EatingFruitExtensions   {   public   static   void   Eat ( this   Fruit   fruit );   }  }   When writing extension methods for an interface the sponsor type name must not start with an  I .", 
            "title": "Extension method patterns"
        }, 
        {
            "location": "/contributing/#assertions", 
            "text": "Use  Debug.Assert()  to assert a condition in the code. Do not use Code Contracts (e.g.  Contract.Assert ).  Please note that assertions are only for our own internal debugging purposes. They do not end up in the released code, so to alert a developer of a condition use an exception.", 
            "title": "Assertions"
        }, 
        {
            "location": "/contributing/#unit-tests-and-functional-tests", 
            "text": "Use  xUnit.net  for all unit testing.", 
            "title": "Unit tests and functional tests"
        }, 
        {
            "location": "/contributing/#assembly-naming", 
            "text": "The unit tests for the  Microsoft.Fruit  assembly live in the  Microsoft.Fruit.Tests  assembly.  The functional tests for the  Microsoft.Fruit  assembly live in the  Microsoft.Fruit.FunctionalTests  assembly.  In general there should be exactly one unit test assembly for each product runtime assembly. In general there should be one functional test assembly per repo. Exceptions can be made for both.", 
            "title": "Assembly naming"
        }, 
        {
            "location": "/contributing/#unit-test-class-naming", 
            "text": "Test class names end with  Test  and live in the same namespace as the class being tested. For example, the unit tests for the  Microsoft.Fruit.Banana  class would be in a  Microsoft.Fruit.BananaTest  class in the test assembly.", 
            "title": "Unit test class naming"
        }, 
        {
            "location": "/contributing/#unit-test-method-naming", 
            "text": "Unit test method names must be descriptive about  what is being tested ,  under what conditions , and  what the expectations are . Pascal casing and underscores can be used to improve readability. The following test names are correct:   They are correct:   PublicApiArgumentsShouldHaveNotNullAnnotation\nPublic_api_arguments_should_have_not_null_annotation   The following test names are incorrect:   Test1\nConstructor\nFormatString\nGetData", 
            "title": "Unit test method naming"
        }, 
        {
            "location": "/contributing/#unit-test-structure", 
            "text": "The contents of every unit test should be split into three distinct stages, optionally separated by these comments:  // Arrange    // Act    // Assert   The crucial thing here is that the  Act  stage is exactly one statement. That one statement is nothing more than a call to the one method that you are trying to test. Keeping that one statement as simple as possible is also very important. For example, this is not ideal:  int   result   =   myObj . CallSomeMethod ( GetComplexParam1 (),   GetComplexParam2 (),   GetComplexParam3 ());   This style is not recommended because way too many things can go wrong in this one statement. All the  GetComplexParamN()  calls can throw for a variety of reasons unrelated to the test itself. It is thus unclear to someone running into a problem why the failure occurred.  The ideal pattern is to move the complex parameter building into the  Arrange  section:  // Arrange  P1   p1   =   GetComplexParam1 ();  P2   p2   =   GetComplexParam2 ();  P3   p3   =   GetComplexParam3 ();  // Act  int   result   =   myObj . CallSomeMethod ( p1 ,   p2 ,   p3 );  // Assert  Assert . AreEqual ( 1234 ,   result );   Now the only reason the line with  CallSomeMethod()  can fail is if the method itself blew up. This is especially important when you're using helpers such as  ExceptionHelper , where the delegate you pass into it must fail for exactly one reason.", 
            "title": "Unit test structure"
        }, 
        {
            "location": "/contributing/#testing-exception-messages", 
            "text": "In general testing the specific exception message in a unit test is important. This ensures that the exact desired exception is what is being tested rather than a different exception of the same type. In order to verify the exact exception it is important to verify the message.  To make writing unit tests easier it is recommended to compare the error message to the RESX resource. However, comparing against a string literal is also permitted.  var   ex   =   Assert . Throws InvalidOperationException (()   =   fruitBasket . GetBananaById ( 1234 ));  Assert . Equal ( Strings . FormatInvalidBananaID ( 1234 ),   ex . Message );", 
            "title": "Testing exception messages"
        }, 
        {
            "location": "/contributing/#use-xunitnets-plethora-of-built-in-assertions", 
            "text": "xUnit.net includes many kinds of assertions \u2013 please use the most appropriate one for your test. This will make the tests a lot more readable and also allow the test runner report the best possible errors (whether it's local or the CI machine). For example:   The following are incorrect:   Assert . Equal ( true ,   someBool );  Assert . True ( abc123   ==   someString );  Assert . True ( list1 . Length   ==   list2 . Length );  for   ( int   i   =   0 ;   i     list1 . Length ;   i ++)  { \n     Assert . True ( String . Equals ,   list1 [ i ],   list2 [ i ],   StringComparison . OrdinalIgnoreCase ));  }    They are good:   Assert . True ( someBool );  Assert . Equal ( abc123 ,   someString );  // built-in collection assertions!  Assert . Equal ( list1 ,   list2 ,   StringComparer . OrdinalIgnoreCase );", 
            "title": "Use xUnit.net's plethora of built-in assertions"
        }, 
        {
            "location": "/contributing/#parallel-tests", 
            "text": "By default all unit test assemblies should run in parallel mode, which is the default. Unit tests shouldn't depend on any shared state, and so should generally be runnable in parallel. If the tests fail in parallel, the first thing to do is to figure out  why ; do not just disable parallel tests!  For functional tests it is reasonable to disable parallel tests.", 
            "title": "Parallel tests"
        }, 
        {
            "location": "/contributing/#solution-and-project-folder-structure-and-naming", 
            "text": "Solution files go in the repo root.  Solution names match repo names (e.g. Mvc.sln in the Mvc repo).  Every project also needs a  project.json  and a matching  .xproj  file. This  project.json  is the source of truth for a project's dependencies and configuration options.  Solutions need to contain solution folders that match the physical folders ( src ,  test , etc.).  For example, in the  Fruit  repo with the  Banana  and  Lychee  projects you would have these files checked in:  /Fruit.sln\n/src\n/src/Fruit.Banana\n/src/Fruit.Banana/project.json\n/src/Fruit.Banana/Banana.kproj\n/src/Fruit.Banana/Banana.cs\n/src/Fruit.Banana/Util/BananaUtil.cs\n/src/Fruit.Lychee\n/src/Fruit.Lychee/project.json\n/src/Fruit.Lychee/Lychee.kproj\n/src/Fruit.Lychee/Lychee.cs\n/src/Fruit.Lychee/Util/LycheeUtil.cs\n/test\n/test/Fruit.Banana.Tests\n/test/Fruit.Banana.Tests/project.json\n/test/Fruit.Banana.Tests/BananaTest.kproj\n/test/Fruit.Banana.Tests/BananaTest.cs\n/test/Fruit.Banana.Tests/Util/BananaUtilTest.cs  Note that after running the  build  command the system will generate the following files:  /build/*.shade  All these files are set to be ignored in the  .gitignore  file.", 
            "title": "Solution and project folder structure and naming"
        }
    ]
}